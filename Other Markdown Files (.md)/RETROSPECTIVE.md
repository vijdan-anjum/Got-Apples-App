# Iteration 2 Retrospective

*Q: As a team complete a retrospective activity based on your work from the*
*previous iteration: discuss a part of your project that has not been as* 
*successful as you would have liked, and how it can be improved in this* 
*iteration (do this early!). Determine concrete (and realistic) ways of* 
*improvement, and decide how its success will be evaluated at the end of the* 
*iteration (measurable and objective). Also include a chart (as an image)* 
*showing the 2 data points of project velocity from the last two iterations.* 
*Submit with this iteration a short (500 word written) description of what you* 
*have discussed, as a file called RETROSPECTIVE.md in your git repository.*


After handing in Iteration 2, our group held a retrospective and reflected on
the things we did right, and things that we did wrong. In Iteration 1's
retrospective, our main problem was not utilizing GitLab to its full potential
and organizational features, so we decided to utilize GitLab even further for
Iteration 2. While we did do just that in Iteration 2 and we were organized
in terms of who is doing what task, we still did not close down issues in time
as we were going back-and-forth on Discord; which was great in terms of
effective communication in the given instance but not quite effective the closer
we were on the due date. That is, a few days before the release, we were not 
entirely sure what tasks were done since we did not close any of the issues we
were sure were finished, so we had to keep asking each other all the time
and we ended up scrambling and not finishing all of integration testing 
and having abundant code smells. So while we were focused on task 
organization, we ended up losing track of time organization and load management,
which hurted our marks the most in Iteration 2 when it came down to the release.
Also, we reflected that our division of tasks by architecture classifications
did not exactly work as planned. Basically, one of us handled persistence 
classes, one handled objects and logic classes, one handled user interface, and 
one handled documentation and testing. This proved to be  harder than anticipated 
since they all correlate and relate, which in turn ended up not making a feature
work when one of the classes did not work. Thus, we all agreed that for 
Iteration 3, we should close every task that we finish, to divide the tasks in 
even smaller tasks and assign every task between us four developers while
focusing on one feature at a time and fully implementing it.


Hence, for the next iteration (iteration 3), we deem ourselves to be successful 
when we have closed **ALL** of the bug issues of high priority, **ALL** of the 
documentation tasks of high priority, at least **80%** of the developer tasks,
and at least **70%** of all the other open features and user stories (and closed
them down right after we finished the issue). The rest of the issues not finished
should all be moved to a future milestone, in case we decide to continue this 
project for a public release.

The image below is a graph showing the project velocity of Iteration 1 and
Iteration 2 (commits are based on developer tasks and user stories):
![](images/Velocity_graph.png)

It is evident that in Iteration 1, we did not utilize GitLab that well, but
we did that much better in Iteration 2. In further investigation, it is 
evident that we closed most of the tasks on the same day of the Iteration 2
due date.